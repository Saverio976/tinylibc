.TH "includes/tlcstrings.h" 3 "Thu Mar 9 2023" "Version 0.0.1" "(my)TinyLibC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
includes/tlcstrings.h
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBx_memcpy\fP (void *dest, const void *src, size_t n)"
.br
.RI "copy bytes of \fCsrc\fP to \fCdest\fP "
.ti -1c
.RI "char * \fBx_strchr\fP (const char *s, int c)"
.br
.RI "search \fCc\fP in \fCs\fP "
.ti -1c
.RI "int \fBx_strcmp\fP (const char *s1, const char *s2)"
.br
.RI "compare two strings "
.ti -1c
.RI "char * \fBx_strcpy\fP (char *dest, const char *src)"
.br
.RI "copy \fCsrc\fP in \fCdest\fP (\fCdest\fP must be able to store \fCsrc\fP) "
.ti -1c
.RI "char * \fBx_strdup\fP (const char *s)"
.br
.RI "duplicate a string "
.ti -1c
.RI "size_t \fBx_strlen\fP (const char *s)"
.br
.RI "get length of a string "
.ti -1c
.RI "char * \fBx_strncpy\fP (char *dest, const char *src, size_t n)"
.br
.RI "copy \fCn\fP char of \fCsrc\fP in \fCdest\fP "
.ti -1c
.RI "char * \fBx_strndup\fP (const char *s, int n)"
.br
.RI "duplicate \fCn\fP char of a string "
.ti -1c
.RI "char * \fBx_strrev\fP (char *str)"
.br
.RI "reverse a string "
.ti -1c
.RI "char ** \fBx_strsplit\fP (const char *s, const char *delim)"
.br
.RI "split a string with delimiter "
.ti -1c
.RI "char * \fBx_strstr\fP (const char *s, const char *substr)"
.br
.RI "search a string in another string "
.ti -1c
.RI "char * \fBx_strstrip\fP (const char *s, const char *chars)"
.br
.RI "remove character at start and end "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void * x_memcpy (void * dest, const void * src, size_t n)"

.PP
copy bytes of \fCsrc\fP to \fCdest\fP 
.PP
\fBParameters\fP
.RS 4
\fIdest\fP where bytes will go 
.br
\fIsrc\fP the bytes source 
.br
\fIn\fP number of bytes to copy
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCdest\fP = 0)|(\fCsrc\fP = 0);; ptr \fCdest\fP 
.RE
.PP

.SS "char * x_strchr (const char * s, int c)"

.PP
search \fCc\fP in \fCs\fP 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string in which to search for \fCc\fP 
.br
\fIc\fP character to search in \fCs\fP
.RE
.PP
\fBReturns\fP
.RS 4
NULL if \fCc\fP is not in \fCs\fP;; ptr to the character 
.RE
.PP

.SS "int x_strcmp (const char * s1, const char * s2)"

.PP
compare two strings 
.PP
\fBParameters\fP
.RS 4
\fIs1\fP strings to compare to \fCs2\fP 
.br
\fIs2\fP strings to compare to \fCs1\fP
.RE
.PP
\fBReturns\fP
.RS 4
0 if \fCs1\fP = \fCs2\fP;; (s1[x] - s2[x]) where s1[x] and s2[x] are != 
.RE
.PP

.SS "char * x_strcpy (char * dest, const char * src)"

.PP
copy \fCsrc\fP in \fCdest\fP (\fCdest\fP must be able to store \fCsrc\fP) 
.PP
\fBParameters\fP
.RS 4
\fIdest\fP string where \fCsrc\fP will be copied 
.br
\fIsrc\fP string of what to copy
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCdest\fP = \fCsrc\fP)|(\fCdest\fP = 0)|(\fCsrc\fP = 0);; ptr to \fCdest\fP 
.RE
.PP

.SS "char * x_strdup (const char * s)"

.PP
duplicate a string 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to duplicate
.RE
.PP
\fBReturns\fP
.RS 4
NULL if \fCs\fP = 0;; ptr to the new duplicate string 
.RE
.PP

.SS "size_t x_strlen (const char * s)"

.PP
get length of a string 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to get the length
.RE
.PP
\fBReturns\fP
.RS 4
0 if \fCs\fP = 0;; the length 
.RE
.PP

.SS "char * x_strncpy (char * dest, const char * src, size_t n)"

.PP
copy \fCn\fP char of \fCsrc\fP in \fCdest\fP 
.PP
\fBParameters\fP
.RS 4
\fIdest\fP string where \fCn\fP char of \fCsrc\fP will go 
.br
\fIsrc\fP string to copy 
.br
\fIn\fP number of char to copy (if n > x_strlen(src), only x_strlen(src))
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCdest\fP = 0)|(\fCsrc\fP = 0);; ptr to \fCdest\fP 
.RE
.PP

.SS "char * x_strndup (const char * s, int n)"

.PP
duplicate \fCn\fP char of a string 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to duplicate 
.br
\fIn\fP number of char to duplicate
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCs\fP = 0)|(\fCn\fP < 0);; ptr to the duplicate 
.RE
.PP

.SS "char * x_strrev (char * str)"

.PP
reverse a string 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP string to update
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCstr\fP = 0);; \fCstr\fP 
.RE
.PP

.SS "char ** x_strsplit (const char * s, const char * delim)"

.PP
split a string with delimiter 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to split 
.br
\fIdelim\fP string to use as a delimiter
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCs\fP = 0)|(\fCdelim\fP = 0);; array of string 
.RE
.PP

.SS "char * x_strstr (const char * s, const char * substr)"

.PP
search a string in another string 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string in which to search for \fCsubstr\fP 
.br
\fIsubstr\fP string to search for in \fCs\fP
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCs\fP = 0)|(\fCsubstr\fP = 0)(\fCsubstr\fP not found)| (\fCs\fP = '')|(\fCsubstr\fP = '');; ptr to match 
.RE
.PP

.SS "char * x_strstrip (const char * s, const char * chars)"

.PP
remove character at start and end 
.PP
\fBParameters\fP
.RS 4
\fIs\fP string to strip the start and end of \fCchars\fP character 
.br
\fIchars\fP character to strip
.RE
.PP
\fBReturns\fP
.RS 4
NULL if (\fCs\fP = 0)|(\fCchars\fP = 0);; new string striped 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for (my)TinyLibC from the source code\&.
